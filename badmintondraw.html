<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Badminton Draw Generator</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" xintegrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
    <style>
        /* General Styling */
/* Component Container */
badminton-draw {
    display: block;
    overflow-x: auto; /* Scroll for large brackets */
    padding: 20px 0;
    margin-bottom: 40px;
    background-color: #fff;
    border-radius: 8px;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
}

/* Bracket Layout */
.bracket-container {
    display: flex;
    flex-direction: row;
    align-items: center; /* Center stages vertically */
    padding: 10px;
}

/* Stage (Round) */
.stage {
    display: flex;
    flex-direction: column;
    justify-content: space-around;
    padding: 15px 30px 15px 0; /* Space for lines */
    min-width: 150px;
    flex-shrink: 0;
}

/* Match Container */
.match {
    display: flex;
    flex-direction: column;
    margin: 10px 0;
    padding-right: 15px; /* Space for match line */
    position: relative;
    list-style: none; /* Remove list bullets if used */
}

/* Player/Score Box */
.player-box {
    background-color: #e0f7fa; /* Light cyan */
    border: 1px solid #00bcd4; /* Cyan border */
    padding: 5px 10px;
    margin: 2px 0;
    border-radius: 4px;
    font-size: 14px;
    font-weight: bold;
    min-width: 120px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.bye-box {
    background-color: #f5f5f5;
    color: #888;
    border: 1px dashed #ccc;
    font-style: italic;
}

.winner {
    background-color: #a5d6a7; /* Light green for winner */
    border-color: #4caf50;
}

/* CSS for drawing lines (The tricky part!) */

/* 1. Horizontal line from player box to center of match */
.match .player-box::after {
    content: '';
    position: absolute;
    right: 0;
    height: 1px;
    width: 15px;
    background-color: #333;
}

/* 2. Vertical line connecting two matches to the next round */
.stage .match:nth-child(odd) > .player-box:last-of-type::after {
    /* Only apply the vertical line style to the second player box in the first match of a pair */
    display: none; /* Hide the default horizontal line */
}

.stage .match-group {
    /* Use a container for two matches to draw the line around them */
    display: flex;
    flex-direction: column;
    position: relative;
    margin: 10px 0;
}

/* The combined line logic */
.stage .match-group::before {
    /* Vertical line */
    content: '';
    position: absolute;
    left: calc(100% - 15px); /* Position it where the horizontal line ends */
    width: 1px;
    background-color: #333;
    top: 50%;
    transform: translateY(-50%);
    height: calc(100% + 20px); /* Height spanning the two matches + margins */
    border-right: 1px solid #333;
}

.stage .match-group::after {
    /* Horizontal line extending from the vertical line to the next stage */
    content: '';
    position: absolute;
    left: calc(100% - 15px);
    top: 50%;
    transform: translateY(-50%);
    width: 30px; /* Length of the line connecting to the next match */
    height: 1px;
    background-color: #333;
}

/* Hide line logic for the final match and when there's only one match */
.bracket-container > .stage:last-child .match-group::before,
.bracket-container > .stage:last-child .match-group::after {
    display: none;
}
/* For the single match in the last stage */
.stage .match-group:only-child::before,
.stage .match-group:only-child::after {
    display: none;
}

table td { vertical-align: middle;  }


    </style>
</head>
<body>

    <table class="table table-bordered">
        <thead>
            <tr>
                <th>Pre Qtr</th>
                <th>Qtr</th>
                <th>Semi Final</th>
                <th>Final</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>P1</td>
                <td rowspan="2"><div>P2</div></td>
                <td rowspan="4">P4</td>
                <td rowspan="8">P5</td>
            </tr>
            <tr>
                <td>P2</td>
            </tr>
            <tr>
                <td>P3</td>
                <td rowspan="2">P4</td>
            </tr>
            <tr>
                <td>P4</td>
            </tr>
            <tr>
                <td>P5</td>
                <td rowspan="2"><div>P5</div></td>
                <td rowspan="4">P5</td>
            </tr>
            <tr>
                <td>P6</td>
            </tr>
            <tr>
                <td>P7</td>
                <td rowspan="2">P8</td>
            </tr>
            <tr>
                <td>P8</td>
            </tr>
        </tbody>
    </table>

    <h1>Badminton Tournament Draws</h1>
    
    <h2>8-Player Draw (Quarter-finals start)</h2>
    <badminton-draw players="8"></badminton-draw>

    <h2>16-Player Draw (Round of 16 start)</h2>
    <badminton-draw players="16"></badminton-draw>
    
    <h2>3-Player Draw (Bye needed)</h2>
    <badminton-draw players="3"></badminton-draw>

    <h2>5-Player Draw (Byes needed)</h2>
    <badminton-draw players="5"></badminton-draw>
<script>
    class BadmintonDraw extends HTMLElement {
    static get observedAttributes() {
        return ['players'];
    }

    constructor() {
        super();
    }

    connectedCallback() {
        this.render();
    }

    attributeChangedCallback(name, oldValue, newValue) {
        if (name === 'players' && oldValue !== newValue) {
            this.render();
        }
    }

    /**
     * Finds the next power of 2 greater than or equal to the player count.
     * e.g., 3 -> 4, 5 -> 8, 8 -> 8
     * @param {number} n - Number of players
     * @returns {number} The required bracket size (power of 2)
     */
    getNextPowerOfTwo(n) {
        if (n <= 0) return 1;
        let p = 1;
        while (p < n) {
            p *= 2;
        }
        return p;
    }

    /**
     * Generates the HTML structure for the bracket.
     */
    render() {
        const playerCount = parseInt(this.getAttribute('players'), 10);
        
        if (isNaN(playerCount) || playerCount < 1) {
            this.innerHTML = '<p>Please specify a valid number of players (e.g., players="8").</p>';
            return;
        }

        const bracketSize = this.getNextPowerOfTwo(playerCount);
        const numRounds = Math.log2(bracketSize);
        const numByes = bracketSize - playerCount;
        
        // Initial setup for the first round matches
        let currentRoundMatches = bracketSize / 2;
        let matchIndex = 1;

        // An array of placeholder players
        let players = Array.from({ length: playerCount }, (_, i) => `Player ${i + 1}`);
        let firstRoundPlayers = [];

        // Distribute players and BYEs (simplistic distribution for this example)
        for (let i = 0; i < bracketSize; i++) {
            if (i < playerCount) {
                firstRoundPlayers.push(players[i]);
            } else {
                firstRoundPlayers.push('BYE');
            }
        }
        
        // For non-power-of-2, we need a specific pattern to match the largest power of 2
        // A common pattern is to pair the numByes players who get byes with the first numByes seeds.
        // For simplicity here, we'll just fill the slots and let the draw generation handle it.
        // For a true competitive draw, seeding/BYE placement is complex.

        let html = '<div class="bracket-container">';

        // === Generate Rounds ===
        for (let round = 1; round <= numRounds; round++) {
            let stageHtml = `<div class="stage round-${round}">`;
            let matchesInRound = bracketSize / Math.pow(2, round);
            
            for (let i = 0; i < matchesInRound; i++) {
                
                // Group two matches (or slots) for the line drawing logic
                let groupHtml = `<div class="match-group">`;
                
                // Only populate the match boxes for the first round (Round 1)
                if (round === 1) {
                    const p1 = firstRoundPlayers.shift() || 'TBD';
                    const p2 = firstRoundPlayers.shift() || 'TBD';
                    
                    groupHtml += `
                        <div class="match match-${matchIndex++}">
                            <div class="player-box ${p1 === 'BYE' ? 'bye-box' : ''}">${p1}</div>
                            <div class="player-box ${p2 === 'BYE' ? 'bye-box' : ''}">${p2}</div>
                        </div>
                    `;
                } else {
                    // For subsequent rounds, just use TBD placeholders
                    groupHtml += `
                        <div class="match match-${matchIndex++}">
                            <div class="player-box">TBD</div>
                            <div class="player-box">TBD</div>
                        </div>
                    `;
                }

                groupHtml += `</div>`; // Close match-group
                stageHtml += groupHtml;
            }

            stageHtml += '</div>'; // Close stage
            html += stageHtml;
        }

        // Add the FINAL stage (Winner)
        html += `
            <div class="stage final-stage">
                <div class="match-group">
                    <div class="match winner-match">
                        <div class="player-box winner">WINNER</div>
                    </div>
                </div>
            </div>
        `;

        html += '</div>'; // Close bracket-container
        this.innerHTML = html;
    }
}

// Define the custom element
customElements.define('badminton-draw', BadmintonDraw);
</script>

</body>
</html>