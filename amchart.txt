class AmChartWebComponent extends HTMLDivElement {
    static get observedAttributes() {
        // Observe the 'config' attribute for changes
        return ['config'];
    }

    constructor() {
        super();
        this.chartRoot = null; // To store the AmCharts root instance
        this.chartContainer = this; // When using 'is', the element itself is the container
        this.amChartsLoaded = false; // Flag to track if AmCharts libraries are loaded
        this.loadingPromise = null; // To store the promise of loading libraries
        this.loadingOverlay = null; // To store the loading overlay element
        this.chartRendered = false; // New flag to track if the chart has been rendered
        this.intersectionObserver = null; // To store the IntersectionObserver instance
        this.dataRenderer = null;
    }

    connectedCallback() {
        // Create and append a loading overlay
        this.loadingOverlay = document.createElement('div');
        this.loadingOverlay.className = 'loading-overlay';
        this.loadingOverlay.innerHTML = '<div class="spinner-border text-primary" role="status"><span class="visually-hidden">Loading...</span></div> <span class="ms-2">Loading chart...</span>';
        this.appendChild(this.loadingOverlay);

        // Set up IntersectionObserver for lazy loading
        this.intersectionObserver = new IntersectionObserver((entries, observer) => {
            entries.forEach(entry => {
                if (entry.isIntersecting && !this.chartRendered) {
                    // If the element is visible and chart not yet rendered, load and render
                    this.loadAmChartsLibraries().then(() => {
                        this.amChartsLoaded = true;
                        this.loadingOverlay.style.display = 'none'; // Hide loading overlay
                        this.renderChart();
                        this.chartRendered = true; // Mark as rendered
                    }).catch(error => {
                        console.error('Failed to load AmCharts libraries:', error);
                        this.loadingOverlay.innerHTML = '<span class="text-danger">Error loading chart.</span>';
                    });
                    observer.disconnect(); // Stop observing once loaded
                }
            });
        }, {
            root: null, // Use the viewport as the root
            rootMargin: '0px',
            threshold: 0.1 // Trigger when 10% of the element is visible
        });

        this.intersectionObserver.observe(this); // Start observing this element
    }

    disconnectedCallback() {
        // Disconnect observer when the element is removed from the DOM
        if (this.intersectionObserver) {
            this.intersectionObserver.disconnect();
        }
        // Dispose of any existing chart root to prevent memory leaks.
        if (this.chartRoot) {
            this.chartRoot.dispose();
            this.chartRoot = null;
        }
    }

    attributeChangedCallback(name, oldValue, newValue) {
        // This method is called when an observed attribute changes.
        if (name === 'config' && oldValue !== newValue) {
            // If the config attribute changes, and chart is already rendered, re-render
            if (this.chartRendered) {
                this.renderChart();
            } else if (this.loadingPromise) {
                // If config changes before rendering, but loading is in progress,
                // ensure it renders once libraries are ready (and it becomes visible)
                this.loadingPromise.then(() => {
                    // Only render if it's visible, otherwise wait for intersection observer
                    if (this.intersectionObserver && this.intersectionObserver.root) { // Check if observer is active
                        const entry = this.intersectionObserver.takeRecords().find(rec => rec.target === this);
                        if (entry && entry.isIntersecting) {
                            this.renderChart();
                        }
                    }
                });
            }
            // If not yet visible and no loading in progress, the IntersectionObserver will handle it.
        }
    }

    /**
     * Helper function to dynamically load a script.
     * @param {string} url - The URL of the script to load.
     * @returns {Promise<void>} A promise that resolves when the script is loaded.
     */
    loadScript(url) {
        return new Promise((resolve, reject) => {
            const script = document.createElement('script');
            script.src = url;
            script.onload = () => resolve();
            script.onerror = () => reject(new Error(`Failed to load script: ${url}`));
            document.head.appendChild(script);
        });
    }

    /**
     * Loads all necessary AmCharts libraries dynamically.
     * @returns {Promise<void>} A promise that resolves when all libraries are loaded.
     */
    loadAmChartsLibraries() {
        if (this.loadingPromise) {
            return this.loadingPromise; // Return existing promise if already loading
        }

        const libUrls = [
            "https://cdn.amcharts.com/lib/5/index.js",
            "https://cdn.amcharts.com/lib/5/xy.js",
            "https://cdn.amcharts.com/lib/5/percent.js", // Added for Pie Charts
            "https://cdn.amcharts.com/lib/5/themes/Animated.js"
        ];

        this.loadingPromise = Promise.all(libUrls.map(url => this.loadScript(url)));
        return this.loadingPromise;
    }
    renderChart() {
        debugger;
        if(typeof this.dataRenderer === 'function') {
            const dtvalue = this.dataRenderer();
            //if(dtvalue) {
                //$(this).data("config", dtvalue);
                //this.setAttribute('config', JSON.stringify(dtvalue));
                //this.renderChart1();
            //}
            // this.wizardNavLinks.innerHTML = this.dataRenderer();
            // this.alinks = this.wizardNavLinks.querySelectorAll("li").length;
        }
    }
    renderChart1() {
        debugger;
        // Only proceed if AmCharts libraries are confirmed loaded
        if (!this.amChartsLoaded) {
            console.warn('AmCharts libraries not loaded yet. Chart will render once ready.');
            return;
        }

        // Dispose of any existing chart root before creating a new one
        if (this.chartRoot) {
            this.chartRoot.dispose();
        }

        try {
        //am5.ready(function () {
            // Parse the config attribute as a JSON object
            const config = JSON.parse(this.getAttribute('config') || '{}');
            //const config = $(this).data("config");
            // Create root element
            this.chartRoot = am5.Root.new(this.chartContainer);

            // Set themes (optional, but good for default aesthetics)
            let atheme;
            if (localStorage.getItem("atheme") == 'dark')
                atheme = [
                    am5themes_Animated.new(this.chartRoot),
                    am5themes_Dark.new(this.chartRoot)
                ];
            else
                atheme = [am5themes_Animated.new(this.chartRoot)];
            
            this.chartRoot.setThemes(atheme);

            let chart;
            switch (config.type) {
                case 'XYChart':
                    chart = this.chartRoot.container.children.push(am5xy.XYChart.new(this.chartRoot, {
                        panX: false,
                        panY: false,
                        paddingLeft: 0,
                        wheelX: "panX",
                        wheelY: "zoomX",
                        layout: this.chartRoot.verticalLayout
                    }));
                    break;
                case 'PieChart':
                    chart = this.chartRoot.container.children.push(am5percent.PieChart.new(this.chartRoot, {
                        layout: this.chartRoot.verticalLayout
                    }));
                    break;
                default:
                    console.error('Unsupported chart type:', config.type);
                    return;
            }

            // Set chart data (common for most charts)
            // if (config.data) {
            //     chart.data.setAll(config.data);
            // }

            // Handle XYChart specific configurations (axes, series)
            if (config.type === 'XYChart') {
                // Create X-axes
                if (config.xAxes && config.xAxes.length > 0) {
                    config.xAxes.forEach(axisConfig => {
                        let xAxis;
                        if (axisConfig.type === 'CategoryAxis') {
                            xAxis = chart.xAxes.push(am5xy.CategoryAxis.new(this.chartRoot, {
                                categoryField: axisConfig.categoryField,
                                renderer: am5xy.AxisRendererX.new(this.chartRoot, axisConfig.renderer || {})
                            }));
                            if (axisConfig.data) {
                                xAxis.data.setAll(axisConfig.data);
                            } else if (config.data) {
                                const categories = config.data.map(d => d[axisConfig.categoryField]);
                                xAxis.data.setAll(categories.map(c => ({ category: c })));
                            }
                        } else if (axisConfig.type === 'ValueAxis') {
                            xAxis = chart.xAxes.push(am5xy.ValueAxis.new(this.chartRoot, {
                                renderer: am5xy.AxisRendererX.new(this.chartRoot, axisConfig.renderer || {})
                            }));
                        }
                        if (xAxis && axisConfig.tooltipText) {
                            xAxis.set("tooltipText", axisConfig.tooltipText);
                        }
                        if (xAxis && axisConfig.labels) { 
                            // Add custom label configs here  
                        }
                    });
                }

                // Create Y-axes
                if (config.yAxes && config.yAxes.length > 0) {
                    config.yAxes.forEach(axisConfig => {
                        let yAxis;
                        if (axisConfig.type === 'ValueAxis') {
                            yAxis = chart.yAxes.push(am5xy.ValueAxis.new(this.chartRoot, {
                                renderer: am5xy.AxisRendererY.new(this.chartRoot, axisConfig.renderer || {})
                            }));
                        } else if (axisConfig.type === 'CategoryAxis') {
                            yAxis = chart.yAxes.push(am5xy.CategoryAxis.new(this.chartRoot, {
                                categoryField: axisConfig.categoryField,
                                renderer: am5xy.AxisRendererY.new(this.chartRoot, axisConfig.renderer || {})
                            }));
                            if (axisConfig.data) {
                                yAxis.data.setAll(axisConfig.data);
                            }
                        }
                        if (yAxis && axisConfig.tooltipText) {
                            yAxis.set("tooltipText", axisConfig.tooltipText);
                        }
                    });
                }
                /*
                debugger;
                for (let i = 1; i < config.dataMain.length; i++) {
                    const ttl = config.dataMain[i].GTitle.replace(/ /g, '-');
                    ////
                    var series = chart.series.push(am5xy.ColumnSeries.new(this.chartRoot, {
                        name: ttl,
                        xAxis: chart.xAxes,
                        yAxis: chart.yAxis,
                        valueYField: ttl,
                        categoryXField: "MnRDate"
                    }));

                    series.columns.template.setAll({
                        tooltipText: "{name}, {categoryX}:{valueY}",
                        width: am5.percent(90),
                        tooltipY: 0,
                        strokeOpacity: 0
                    });

                    series.data.setAll(config.data);

                    // Make stuff animate on load
                    // https://www.amcharts.com/docs/v5/concepts/animations/
                    series.appear();

                    series.bullets.push(function () {
                        return am5.Bullet.new(this.chartRoot, {
                            locationY: 0,
                            sprite: am5.Label.new(this.chartRoot, {
                                text: "{valueY}",
                                fill: this.chartRoot.interfaceColors.get("alternativeText"),
                                centerY: 0,
                                centerX: am5.p50,
                                populateText: true
                            })
                        });
                    });

                    legend.data.push(series);


                    ////
                    //this.makeSeries(chart, ttl, ttl, config.data);
                }*/


                // Create XYChart series (ColumnSeries, LineSeries)
                if (config.series && config.series.length > 0) {
                    debugger;
                    config.series.forEach(seriesConfig => {
                        let series;
                        if (seriesConfig.type === 'ColumnSeries') {
                            series = chart.series.push(am5xy.ColumnSeries.new(this.chartRoot, {
                                name: seriesConfig.name,
                                xAxis: chart.xAxes.getIndex(0),
                                yAxis: chart.yAxes.getIndex(0),
                                valueYField: seriesConfig.valueField.toLowerCase(),
                                categoryXField: seriesConfig.categoryField,
                                tooltip: am5.Tooltip.new(this.chartRoot, {
                                    labelText: "{name}: {valueY}"
                                })
                            }));
                            // Add custom settings to the column template from the config
                            if (seriesConfig.columns && seriesConfig.columns.template) {
                                for (const prop in seriesConfig.columns.template) {
                                    if (prop === 'fill' && typeof seriesConfig.columns.template[prop] === 'string' && seriesConfig.columns.template[prop].startsWith('am5.color(')) {
                                        series.columns.template.set(prop, eval(seriesConfig.columns.template[prop]));
                                    } else {
                                        series.columns.template.set(prop, seriesConfig.columns.template[prop]);
                                    }
                                }
                            }
                        } else if (seriesConfig.type === 'LineSeries') {
                            series = chart.series.push(am5xy.LineSeries.new(this.chartRoot, {
                                name: seriesConfig.name,
                                xAxis: chart.xAxes.getIndex(0),
                                yAxis: chart.yAxes.getIndex(0),
                                valueYField: seriesConfig.valueField,
                                categoryXField: seriesConfig.categoryField,
                                tooltip: am5.Tooltip.new(this.chartRoot, {
                                    labelText: "{name}: {valueY}"
                                })
                            }));
                            series.strokes.template.setAll({
                                strokeWidth: 2
                            });
                            // Add bullets
                            if (seriesConfig.bullets) {
                                series.bullets.push(function () {
                                    return am5.Bullet.new(this.chartRoot, {
                                        sprite: am5.Circle.new(this.chartRoot, {
                                            radius: 5,
                                            fill: series.get("fill")
                                        })
                                    });
                                });
                            }
                        }
                        if (series) {
                            series.data.setAll(config.data);
                        }
                    });
                }
/**/
                // Add cursor and scrollbars for XYChart

                chart.set("cursor", am5xy.XYCursor.new(this.chartRoot, {}));
                // chart.set("scrollbarX", am5.Scrollbar.new(this.chartRoot, {
                //     orientation: am5.Orientation.HORIZONTAL
                // }));
                // Add legend if configured
                if (config.legend) {
                    let legend = chart.children.push(am5.Legend.new(this.chartRoot, {
                        centerX: am5.p50,
                        x: am5.p50
                    }));
                    legend.data.setAll(chart.series.values);
                }

            } else if (config.type === 'PieChart') {
                // Create PieChart series
                if (config.series && config.series.length > 0) {
                    config.series.forEach(seriesConfig => {
                        if (seriesConfig.type === 'PieSeries') {
                            let series = chart.series.push(am5percent.PieSeries.new(this.chartRoot, {
                                valueField: seriesConfig.valueField,
                                categoryField: seriesConfig.categoryField
                            }));
                            series.data.setAll(config.data);

                            // Add labels and ticks
                            series.labels.template.setAll({
                                textType: "circular",
                                radius: 10
                            });
                            series.ticks.template.setAll({
                                forceHidden: true
                            });

                            // Add tooltips
                            series.slices.template.set("tooltipText", "{category}: {valuePercentTotal.formatNumber('#.#')}% ({value})");
                        }
                    });
                }
                // Add a legend
                if (config.legend) {
                    let legend = chart.children.push(am5.Legend.new(this.chartRoot, {
                        centerX: am5.p50,
                        x: am5.p50
                    }));
                    legend.data.setAll(chart.series.values[0].dataItems);
                }
            }

            // Make stuff animate on load
            chart.appear(1000, 100);
        //});

        } catch (error) {
            console.error('Error rendering AmChart:', error);
        }
    }
}

// Define the custom element, extending 'div' see example amchart2.html
customElements.define('am-chart-component', AmChartWebComponent, { extends: 'div' });
