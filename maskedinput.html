<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web Component Time Masking</title>
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" xintegrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }

        /* Custom styles for the input, to override some defaults */
        .mask-input-container {
            display: inline-flex;
            width: 100%;
            position: relative;
        }
    </style>


<!-- 



SELECT a.*, b.*,a0.FName,a0.LName,a0.NId,s.SName,ae.EName,ae.ELevel FROM AccountEventsA AS a
LEFT OUTER JOIN AccountEventsA0 AS b ON a.AEventId=b.AEventId
LEFT OUTER JOIN Account AS a0 ON a0.AccountId=b.AccountId
LEFT OUTER JOIN AllSports AS s ON s.SId=a.SId
LEFT OUTER JOIN AccountEvents AS ae ON ae.EventId=b.FEventId
WHERE b.FEventId = 3
ORDER BY b.AgeGroup, b.Gender, a.AthleteClass


SELECT TOP (200) AStatus, AccountId, PAccountId, NId, AadharNo, ACode, OCode, ATitle, Gender, FName, MName, LName, ALink, BirthDate, BirthTime, BirthPlace, JoinDate, Age, BloodGroup, Email, Mobile, WhatsAppNo, PhoneR, PhoneO, 
                  Password, DeptId, DesgId, MaritalStatus, Nationality, AAddress, StatusOfResidential, LocalityCAddress, CCountry, CState, TownCAddress, CDistrict, CPinCode, PermanentAddress, LocalityPAddress, PCountry, PState, TownPAddress, 
                  PDistrict, PPinCode, LocalAddress, LocalityLAddress, LCountry, LState, TownLAddress, LDistrict, LPinCode, AltEmail, AltMobile, FaxNo, DrivingLicenseNo, DrivingLicenseI, ProofOfAddress, ProofOfIdentity, LinkedTo, FatherName, 
                  MotherName, GuardianName, IncTaxSlab, RouteId, ContactPerson, AColor, OpenDate, OpenBal, OpenDrCr, AcNote, ADImage, AImages, EduId, OccupationId, Caste, SubCaste, Disability, DisabilityPer, DisabilityI, AadharI, VotingCardNo, 
                  VotingCardI, RashanCard, RashanI, PanCardNo, PanCardI, PassportNo, PassportIssueDt, PassportExpDt, PassportIssueAt, PassportI, GSTTIN, GSTTINI, CGeoLocation, PGeoLocation, LGeoLocation, Facebook, Instagram, Twitter, 
                  Youtube, LinkedIn, Social1, Social2, Social3, AShowWeb, PassOutYear, AStandard, PassportFileNo, PassportONo, PassportOIssueDt, PassportOIssueAt, PassportOExpDt, PassportOFileNo, PassportOI, AHeight, AWeight, ARashi, AVarna, 
                  AGotra, AMulgaon, AMama, MonthlyIncome, AEducation, AllowedOption, AllowedViews, UtilizedViews, ATotalViews, AcFlow, AKundli, Webaddress, IdentityMark1, IdentityMark2, CastCategory, LinguisticMinority, ReligiousMinority, 
                  SameAddress, SameLAddress, MotherTongue, Religion, LanguageKnown, ACreatedDate, ACreatedBy, ADelegatedTo, Domicile, PersonRelation, PrnNo, CompanyType, IsMSME, ScopeofSupplies, IsMinority, ApplyUnder3, FatherFName, 
                  FatherMName, FatherLName, FatherMobile, FatherBirthDate, FatherEMail, FatherQualification, FatherProfession, MotherFName, MotherMName, MotherLName, MotherBirthDate, MotherMobile, MotherEMail, MotherQualification, 
                  MotherProfession, GuardianFName, GuardianMName, GuardianLName, GuardianMobile, GuardianRelation, GuardianEMail, GuardianQualification, GuardianProfession, Defence, MedicallyFit, VEmail, VMobile, VFatherMobile, VFatherEMail, 
                  VMotherMobile, VMotherEMail, VGuardianMobile, VGuardianEMail, SiblingId, MFName, MMName, MLName, PStatus, EmployedIn, OrganizationName, Designation, Qualification, Relationship, ChildNo, DefaultCommunication, TrustName, 
                  YearOfEstablishment, IVision, IMission, LongGoals, ShortGoals, QualityPolicy, ILocation, IType, ITypeByGender, IShifts, IOwnership, IDefault, IPrograms, ICourses, IAffiliationStatus, OrganizationStructureI, PhoneExtn, NameAsPerAadhar, 
                  EmergencyContact, Hobies, HSNCode, RegisteredIn, TranspPerKg, EnrolmentNo, UDIDNumber, ApplicationName, DateofBirth, MarkofIdentification, Category, ContactNumberofRelatedPerson, SpouseName, CorrespondenceAddress, 
                  DoorNoStreetName, District, SubDIstrict, VillageCity, Pincode, DisabilityType, ApplicationStatus, ApplicationReceivedOn, StateID, IsDigitization, ApplicationType, DisplayName, DisabilityPercentage, SrNoCertificateNo, HospitalName, 
                  EmailTo, EmailCC
FROM     Account
WHERE  (AadharNo IN
                      (SELECT AadharNo
                       FROM      Account AS Account_1
                       GROUP BY AadharNo
                       HAVING  (COUNT(*) > 1)))
ORDER BY AadharNo

-->
</head>
<body class="bg-dark text-light d-flex align-items-center justify-content-center min-vh-100 p-4">
    <div class="card bg-secondary text-light p-5 shadow-lg rounded" style="width: 100%; max-width: 600px;">
        <h1 class="h1 fw-bold text-center text-white mb-2">Flexible Input Mask</h1>
        <p class="text-center text-light">
            This example demonstrates a custom HTML element that uses JavaScript to apply different input masks without relying on the Shadow DOM.
        </p>

        <div class="mt-4 mb-4">
            <!-- Example 1: Time Mask -->
            <div class="mb-3">
                <label for="timeInput" class="form-label text-light">
                    Time Input (HH:MM:SS)
                </label>
                <time-mask-input id="timeInput" data-mask="##:##.##" data-max-value="60" class="mask-input-container">
                    <!-- The input element will be generated here by the custom component -->
                </time-mask-input>
            </div>

            <!-- Example 2: Zip Code Mask -->
            <div class="mb-3">
                <label for="zipInput" class="form-label text-light">
                    Zip Code Input (5 Digits)
                </label>
                <time-mask-input id="zipInput" data-mask="#####" class="mask-input-container">
                    <!-- The input element will be generated here by the custom component -->
                </time-mask-input>
            </div>
            
            <!-- Example 3: Phone Number Mask -->
            <div class="mb-3">
                <label for="phoneInput" class="form-label text-light">
                    Phone Number Mask
                </label>
                <time-mask-input id="phoneInput" data-mask="(###) ###-####" class="mask-input-container">
                    <!-- The input element will be generated here by the custom component -->
                </time-mask-input>
            </div>
        </div>

        <p class="small text-center text-muted mt-4">
            Try typing numbers and using backspace to see the masking in action.
        </p>
    </div>

    <script>
        // Set up an alias for the console log to avoid cluttering production code
        const consoleDebug = () => { };
        // If you want to see debug messages, uncomment the line below.
        // const consoleDebug = console.log;

        /**
         * A custom element for a masked input field.
         * It applies a mask to the user input in real-time.
         */
        class MaskInput extends HTMLElement {
            constructor() {
                super();

                // Get the mask from the data attribute, or use a default if not provided.
                this.mask = this.getAttribute('data-mask') || '';
                this.maskChar = '#';

                // Get the max value from data attribute for validation
                this.maxValue = parseInt(this.getAttribute('data-max-value'), 10) || null;

                // Create the input element. We are not using Shadow DOM, so we attach it directly.
                this.input = document.createElement('input');
                this.input.type = 'text';
                this.input.className = 'form-control bg-dark text-white border-0 shadow-none';
                this.input.placeholder = this.mask.replace(new RegExp(this.maskChar, 'g'), '_');

                this.lastValue = '';
            }

            connectedCallback() {
                // Append the input to the custom element
                this.appendChild(this.input);

                // Add event listeners for input and keydown events
                this.input.addEventListener('input', this.handleInput.bind(this));
                this.input.addEventListener('keydown', this.handleKeydown.bind(this));

                // Initialize the value on connection
                this.updateValue('');
            }

            /**
             * Handles keydown events, primarily for backspace.
             * @param {KeyboardEvent} event
             */
            handleKeydown(event) {
                if (event.key === 'Backspace') {
                    // Get the current cursor position
                    const cursorPosition = this.input.selectionStart;
                    if (cursorPosition > 0) {
                        const currentValue = this.input.value;
                        const previousChar = currentValue[cursorPosition - 1];

                        // If the character before the cursor is a mask character (like ':' or '-'),
                        // we need to step back an extra position to handle the number correctly.
                        const rawValue = this.stripMask(currentValue);
                        let newRawValue = rawValue.slice(0, cursorPosition - 1) + rawValue.slice(cursorPosition - 1);

                        // Find the corresponding mask position
                        let maskIndex = 0;
                        let digitCount = 0;
                        for (let i = 0; i < this.mask.length; i++) {
                            if (this.mask[i] === this.maskChar) {
                                digitCount++;
                                if (i >= cursorPosition) {
                                    break;
                                }
                            } else {
                                maskIndex++;
                            }
                        }

                        // Update the value with the backspace logic
                        this.updateValue(newRawValue);
                        
                        // Recalculate and set the new cursor position
                        const newCursorPosition = this.getNewCursorPosition(currentValue, this.input.value, cursorPosition, event.key);
                        this.input.setSelectionRange(newCursorPosition, newCursorPosition);
                    }
                }
            }

            /**
             * Handles input events, applying the mask in real-time.
             * @param {InputEvent} event
             */
            handleInput(event) {
                // Get the current cursor position and the full value.
                const cursorPosition = this.input.selectionStart;
                const fullValue = this.input.value;

                // Strip the mask to get only the raw numbers.
                let rawValue = this.stripMask(fullValue);
                
                // Validate the raw value against the max value if the mask is for time (##:##:##)
                if (this.mask === '##:##:##' && this.maxValue !== null) {
                    rawValue = this.validateTimeValue(rawValue);
                }

                // Update the value with the applied mask.
                this.updateValue(rawValue);

                // Recalculate and set the new cursor position.
                const newCursorPosition = this.getNewCursorPosition(this.lastValue, this.input.value, cursorPosition, event.inputType);
                this.input.setSelectionRange(newCursorPosition, newCursorPosition);

                // Store the last valid value.
                this.lastValue = this.input.value;
            }

            /**
             * Strips the mask from the input value, returning only the digits.
             * @param {string} value
             * @returns {string} The raw, unmasked value.
             */
            stripMask(value) {
                const digits = value.split('').filter(char => char >= '0' && char <= '9');
                return digits.join('');
            }

            /**
             * Applies the mask to a raw value, inserting mask characters.
             * @param {string} rawValue
             * @returns {string} The masked value.
             */
            applyMask(rawValue) {
                let maskedValue = '';
                let rawIndex = 0;
                for (let i = 0; i < this.mask.length; i++) {
                    if (rawIndex >= rawValue.length) {
                        break;
                    }
                    if (this.mask[i] === this.maskChar) {
                        maskedValue += rawValue[rawIndex];
                        rawIndex++;
                    } else {
                        maskedValue += this.mask[i];
                    }
                }
                return maskedValue;
            }

            /**
             * Updates the input field's value with the masked string.
             * @param {string} rawValue
             */
            updateValue(rawValue) {
                const newValue = this.applyMask(rawValue);
                this.input.value = newValue;
            }

            /**
             * Validates a raw time value to ensure minutes and seconds are not greater than 59.
             * @param {string} rawValue
             * @returns {string} The validated and potentially modified raw value.
             */
            validateTimeValue(rawValue) {
                let validatedValue = '';
                // Hours
                validatedValue += rawValue.substring(0, 2);
                
                // Minutes
                let minutes = rawValue.substring(2, 4);
                if (minutes.length === 2 && parseInt(minutes, 10) >= 60) {
                    minutes = '59';
                }
                validatedValue += minutes;

                // Seconds
                let seconds = rawValue.substring(4, 6);
                if (seconds.length === 2 && parseInt(seconds, 10) >= 60) {
                    seconds = '59';
                }
                validatedValue += seconds;

                return validatedValue;
            }

            /**
             * Calculates the new cursor position after applying the mask.
             * @param {string} oldValue
             * @param {string} newValue
             * @param {number} oldCursorPosition
             * @param {string} inputType
             * @returns {number} The new cursor position.
             */
            getNewCursorPosition(oldValue, newValue, oldCursorPosition, inputType) {
                let newPos = oldCursorPosition;

                // Handle backspace logic for cursor position
                if (inputType === 'deleteContentBackward') {
                    // Find the last digit before the cursor
                    for (let i = newPos - 1; i >= 0; i--) {
                        if (this.mask[i] === this.maskChar) {
                            newPos = i + 1;
                            break;
                        }
                    }
                    if (newPos === 0) {
                        newPos = 0;
                    }
                    return newPos;
                }

                // Handle normal typing
                let addedChars = newValue.length - oldValue.length;
                newPos += addedChars;

                if (newPos < this.mask.length && this.mask[newPos-1] !== this.maskChar) {
                    newPos++;
                }

                return newPos;
            }
        }

        // Define the custom element
        customElements.define('time-mask-input', MaskInput);

    </script>
    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js" xintegrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz" crossorigin="anonymous"></script>
</body>
</html>
