<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Page Loader Example</title>
    <style>
        /* Basic styling for demonstration */
        article[is="page-loader"] {
            display: block;
            border: 1px solid #ccc;
            padding: 15px;
            margin-top: 20px;
            min-height: 100px;
            background-color: #f9f9f9;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            border-radius: 8px;
            font-family: "Inter", sans-serif;
        }
        .loading-message, .error-message, .initial-message {
            text-align: center;
            padding: 20px;
            color: #555;
            font-style: italic;
        }
        .error-message {
            color: #d9534f;
            font-weight: bold;
        }
        button {
            padding: 10px 15px;
            margin: 5px;
            border: none;
            border-radius: 5px;
            background-color: #007bff;
            color: white;
            cursor: pointer;
            font-size: 1rem;
            transition: background-color 0.3s ease;
        }
        button:hover {
            background-color: #0056b3;
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
    </style>
</head>
<body>

    <h1>My Application</h1>
    <button id="loadPageBtn">Load Dynamic Page</button>
    <button id="closePageBtn">Close Page</button>

    <!-- Using an article with the 'is' attribute and autoload -->
    <article is="page-loader" id="myPageLoader" api-url="http://127.0.0.1:5500/pageloaderex.html" autoload></article>

    <script src="page-loader-component.js"></script>
    <script>
        const pageLoader = document.getElementById('myPageLoader');
        const loadPageBtn = document.getElementById('loadPageBtn');
        const closePageBtn = document.getElementById('closePageBtn');

        // Function to update button visibility based on component state
        function updateButtonVisibility() {
            if (pageLoader.contentLoaded) {
                loadPageBtn.style.display = 'none';
                closePageBtn.style.display = 'inline-block';
            } else {
                loadPageBtn.style.display = 'inline-block';
                closePageBtn.style.display = 'none';
            }
            loadPageBtn.disabled = pageLoader.isLoading;
            closePageBtn.disabled = pageLoader.isLoading || !pageLoader.contentLoaded;
        }

        // Initial button state
        updateButtonVisibility();

        loadPageBtn.addEventListener('click', () => {
            pageLoader.loadContent();
        });

        closePageBtn.addEventListener('click', () => {
            pageLoader.closeContent();
        });

        // Event listeners for custom processes
        pageLoader.addEventListener('pageloaded', (event) => {
            console.log('Page Loaded Custom Process:', event.detail.content);
            const loadedContentDiv = pageLoader.querySelector('#content-from-api');
            if (loadedContentDiv) {
                const newParagraph = document.createElement('p');
                newParagraph.textContent = 'This content was added dynamically AFTER the page loaded.';
                loadedContentDiv.appendChild(newParagraph);
            }
            updateButtonVisibility();
        });

        pageLoader.addEventListener('pageloading', () => {
            console.log('Page is starting to load...');
            updateButtonVisibility();
        });

        pageLoader.addEventListener('pageloaderror', (event) => {
            console.error('Page Load Error Custom Process:', event.detail.error);
            updateButtonVisibility();
        });

        pageLoader.addEventListener('beforepageclose', (event) => {
            console.log('Before Page Close Custom Process.');
            if (!confirm('Are you sure you want to close this page?')) {
                event.preventDefault(); // Prevent closing
            }
        });

        pageLoader.addEventListener('afterpageclose', () => {
            console.log('After Page Close Custom Process.');
            alert('The page has been closed!');
            updateButtonVisibility();
        });

        pageLoader.addEventListener('beforesubmit', (event) => {
            console.log('Before Submit Custom Process.', event.detail.formData);
            if (event.detail.formData.get('name') === '') {
                alert('Name cannot be empty!');
                event.preventDefault(); // Prevent submit
            }
        });

        pageLoader.addEventListener('aftersubmit', (event) => {
            console.log('After Submit Custom Process.', event.detail.response);
            alert('Form submitted successfully!');
        });

        pageLoader.addEventListener('errorsubmit', (event) => {
            console.error('Error in Submit Custom Process.', event.detail.error);
            alert('There was an error submitting the form: ' + event.detail.error.message);
        });

        pageLoader.addEventListener('settoinput', (event) => {
            console.log('Set to Input Custom Process.', event.detail.field, event.detail.value);
        });

        pageLoader.addEventListener('afterreset', () => {
            console.log('Form reset custom process.');
        });

        // Triggering set to input after a delay
        setTimeout(() => {
            pageLoader.setContentToInput('email', 'updated.test@example.com');
        }, 3000);
    </script>
    <script>

//```javascript
class PageLoader extends HTMLElement {
    constructor() {
        super();
        // Internal state variables
        this._isLoading = false;
        this._contentLoaded = false;
        this._errorMessage = '';
        this._initialInnerHTML = this.innerHTML; // Store initial content of the <article> tag

        // Bind event handlers to the instance
        this._handleFormSubmit = this._handleFormSubmit.bind(this);
    }

    // Public getters for state
    get isLoading() { return this._isLoading; }
    get contentLoaded() { return this._contentLoaded; }
    get errorMessage() { return this._errorMessage; }

    static get observedAttributes() {
        return ['api-url', 'autoload'];
    }

    attributeChangedCallback(name, oldValue, newValue) {
        if (name === 'api-url' && oldValue !== newValue && this._contentLoaded) {
            // If API URL changes and content is already loaded, re-load
            this.loadContent();
        }
        // No specific action needed for 'autoload' change after initial connection
    }

    connectedCallback() {
        // Render initial state (placeholder or loading if autoload)
        this._render();

        // If autoload attribute is present and content is not already loaded or loading, load content automatically
        if (this.hasAttribute('autoload') && !this._contentLoaded && !this._isLoading) {
            this.loadContent();
        }
        this._addEventListeners();
    }

    disconnectedCallback() {
        this._removeEventListeners();
    }

    /**
     * Renders the component's internal HTML based on its current state.
     * This method centralizes UI updates.
     */
    _render() {
        if (this._errorMessage) {
            this.innerHTML = `<div class="error-message">Error: ${this._errorMessage}</div>`;
        } else if (this._isLoading) {
            this.innerHTML = `<div class="loading-message">Loading content...</div>`;
        } else if (!this._contentLoaded) {
            this.innerHTML = this._initialInnerHTML || `<div class="initial-message">Click "Load Dynamic Page" or add 'autoload' attribute to load content.</div>`;
        }
        // If content is loaded, its innerHTML is already set by loadContent, so no change here.
    }

    /**
     * Fetches HTML content from the API and inserts it.
     */
    async loadContent() {
        if (this._isLoading) return; // Prevent multiple simultaneous loads

        this._isLoading = true;
        this._errorMessage = ''; // Clear previous errors
        this._contentLoaded = false; // Mark content as not yet loaded
        this._render(); // Show loading message

        // Dispatch 'pageloading' event
        this.dispatchEvent(new CustomEvent('pageloading', {
            bubbles: true,
            composed: true,
            detail: { url: this.getAttribute('api-url') }
        }));

        const apiUrl = this.getAttribute('api-url');
        if (!apiUrl) {
            this._errorMessage = 'API URL is missing.';
            this._isLoading = false;
            this._render(); // Show error message
            this.dispatchEvent(new CustomEvent('pageloaderror', {
                bubbles: true,
                composed: true,
                detail: { error: new Error(this._errorMessage), url: apiUrl }
            }));
            return;
        }

        try {
            const response = await fetch(apiUrl);
            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`HTTP error! status: ${response.status} - ${errorText.substring(0, 100)}`);
            }
            const htmlContent = await response.text();

            // Directly insert content. We don't call _render() here because
            // _render() would overwrite the content with loading/error messages.
            this.innerHTML = htmlContent;

            this._contentLoaded = true;
            this._isLoading = false;
            this._errorMessage = ''; // Clear error on success

            // **Custom Process After Load:**
            // Dispatch a custom event for external customization
            this.dispatchEvent(new CustomEvent('pageloaded', {
                bubbles: true,
                composed: true,
                detail: {
                    content: htmlContent,
                    element: this,
                    url: apiUrl
                }
            }));

            this._setupFormHandling(); // Setup form handling if any forms are loaded
        } catch (error) {
            console.error('PageLoader: Error loading content:', error);
            this._errorMessage = `Failed to load content: ${error.message}`;
            this._isLoading = false;
            this._render(); // Show error message

            // Dispatch 'pageloaderror' event
            this.dispatchEvent(new CustomEvent('pageloaderror', {
                bubbles: true,
                composed: true,
                detail: { error: error, url: apiUrl }
            }));
        }
    }

    /**
     * Closes the loaded content, restoring initial state or clearing.
     */
    closeContent() {
        if (!this._contentLoaded && !this._isLoading) return; // Nothing to close

        const event = new CustomEvent('beforepageclose', {
            bubbles: true,
            composed: true,
            cancelable: true // Allow prevention
        });
        this.dispatchEvent(event);

        if (event.defaultPrevented) {
            console.log('Page close was prevented by a custom handler.');
            return;
        }

        this._removeFormHandling(); // Clean up form event listeners BEFORE clearing innerHTML
        this._contentLoaded = false;
        this._isLoading = false;
        this._errorMessage = ''; // Clear any active error
        this.innerHTML = this._initialInnerHTML || `<div class="initial-message">Content closed.</div>`; // Restore initial state or placeholder

        // **Custom Process After Close:**
        this.dispatchEvent(new CustomEvent('afterpageclose', {
            bubbles: true,
            composed: true
        }));
    }

    /**
     * INTERNAL: Sets up event listeners for forms within the loaded content.
     */
    _setupFormHandling() {
        const forms = this.querySelectorAll('form');
        forms.forEach(form => {
            form.addEventListener('submit', this._handleFormSubmit);
        });
    }

    /**
     * INTERNAL: Removes event listeners for forms within the loaded content.
     */
    _removeFormHandling() {
        const forms = this.querySelectorAll('form');
        forms.forEach(form => {
            form.removeEventListener('submit', this._handleFormSubmit);
        });
    }

    /**
     * INTERNAL: Handles form submission within the loaded content.
     * Dispatches custom events for before/after/error in submit.
     */
    _handleFormSubmit = async (event) => {
        event.preventDefault(); // Prevent default form submission

        const form = event.target;
        const formData = new FormData(form);

        // **Custom Process Before Submit:**
        const beforeSubmitEvent = new CustomEvent('beforesubmit', {
            bubbles: true,
            composed: true,
            cancelable: true,
            detail: {
                form: form,
                formData: formData
            }
        });
        this.dispatchEvent(beforeSubmitEvent);

        if (beforeSubmitEvent.defaultPrevented) {
            console.log('Form submission prevented by a custom handler.');
            return;
        }

        const action = form.action || ''; // Get form action
        const method = form.method || 'POST'; // Get form method, default to POST

        try {
            const response = await fetch(action, {
                method: method.toUpperCase(),
                body: formData,
                // You might need to adjust headers based on your API
                // headers: {
                //     'Content-Type': 'application/json' // If sending JSON, use JSON.stringify(Object.fromEntries(formData))
                // }
            });

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({ message: 'Unknown error' }));
                throw new Error(errorData.message || `HTTP error! status: ${response.status}`);
            }

            const responseData = await response.json();

            // **Custom Process After Submit:**
            this.dispatchEvent(new CustomEvent('aftersubmit', {
                bubbles: true,
                composed: true,
                detail: {
                    form: form,
                    formData: formData,
                    response: responseData
                }
            }));
        } catch (error) {
            console.error('PageLoader: Form submission error:', error);
            // **Custom Process Error in Submit:**
            this.dispatchEvent(new CustomEvent('errorsubmit', {
                bubbles: true,
                composed: true,
                detail: {
                    form: form,
                    formData: formData,
                    error: error
                }
            }));
        }
    };

    /**
     * Allows setting values to input fields within the loaded content.
     * @param {string} fieldName - The 'name' attribute of the input field.
     * @param {string} value - The value to set.
     */
    setContentToInput(fieldName, value) {
        const input = this.querySelector(`[name="${fieldName}"]`);
        if (input) {
            input.value = value;
            // **Custom Process Set to Input:**
            this.dispatchEvent(new CustomEvent('settoinput', {
                bubbles: true,
                composed: true,
                detail: {
                    field: fieldName,
                    value: value,
                    inputElement: input
                }
            }));
        } else {
            console.warn(`PageLoader: Input field with name "${fieldName}" not found.`);
        }
    }

    /**
     * Resets all forms within the loaded content.
     * **Custom Process Reset:** Dispatches 'afterreset' event.
     */
    resetContent() {
        const forms = this.querySelectorAll('form');
        forms.forEach(form => form.reset());

        this.dispatchEvent(new CustomEvent('afterreset', {
            bubbles: true,
            composed: true
        }));
    }

    /**
     * Gets current form data as an object (if forms are present).
     * This can be used for "List Parameters" conceptually.
     * @returns {object} An object containing form data.
     */
    getFormData() {
        const data = {};
        const forms = this.querySelectorAll('form');
        forms.forEach(form => {
            const formData = new FormData(form);
            for (let [key, value] of formData.entries()) {
                data[key] = value;
            }
        });
        return data;
    }

    // --- Customization points for Data Operations (Conceptual) ---
    // These methods would typically call your backend API and dispatch events.

    /**
     * Conceptual method to trigger a list operation.
     * Dispatches 'beforelist' and 'afterlist' events.
     */
    async listData(params = {}) {
        const beforeListEvent = new CustomEvent('beforelist', {
            bubbles: true,
            composed: true,
            cancelable: true,
            detail: { params: params }
        });
        this.dispatchEvent(beforeListEvent);

        if (beforeListEvent.defaultPrevented) {
            console.log('List operation prevented.');
            return;
        }

        try {
            // Simulate API call
            const response = await fetch('/api/list', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params)
            });
            const data = await response.json();

            this.dispatchEvent(new CustomEvent('afterlist', {
                bubbles: true,
                composed: true,
                detail: { data: data, params: params }
            }));
            return data;
        } catch (error) {
            console.error('Error listing data:', error);
            this.dispatchEvent(new CustomEvent('errorlist', {
                bubbles: true,
                composed: true,
                detail: { error: error, params: params }
            }));
        }
    }

    /**
     * Conceptual method to trigger an add operation.
     * Dispatches 'beforeadd' and 'afteradd' events.
     */
    async addData(data) {
        const beforeAddEvent = new CustomEvent('beforeadd', {
            bubbles: true,
            composed: true,
            cancelable: true,
            detail: { data: data }
        });
        this.dispatchEvent(beforeAddEvent);

        if (beforeAddEvent.defaultPrevented) {
            console.log('Add operation prevented.');
            return;
        }

        try {
            // Simulate API call
            const response = await fetch('/api/add', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(data)
            });
            const responseData = await response.json();

            this.dispatchEvent(new CustomEvent('afteradd', {
                bubbles: true,
                composed: true,
                detail: { response: responseData, data: data }
            }));
            return responseData;
        } catch (error) {
            console.error('Error adding data:', error);
            this.dispatchEvent(new CustomEvent('erroradd', {
                bubbles: true,
                composed: true,
                detail: { error: error, data: data }
            }));
        }
    }

    /**
     * Conceptual method to trigger an update operation.
     * Dispatches 'beforeupdate' and 'afterupdate' events.
     */
    async updateData(id, data) {
        const beforeUpdateEvent = new CustomEvent('beforeupdate', {
            bubbles: true,
            composed: true,
            cancelable: true,
            detail: { id: id, data: data }
        });
        this.dispatchEvent(beforeUpdateEvent);

        if (beforeUpdateEvent.defaultPrevented) {
            console.log('Update operation prevented.');
            return;
        }

        try {
            // Simulate API call
            const response = await fetch(`/api/update/${id}`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(data)
            });
            const responseData = await response.json();

            this.dispatchEvent(new CustomEvent('afterupdate', {
                bubbles: true,
                composed: true,
                detail: { response: responseData, id: id, data: data }
            }));
            return responseData;
        } catch (error) {
            console.error('Error updating data:', error);
            this.dispatchEvent(new CustomEvent('errorupdate', {
                bubbles: true,
                composed: true,
                detail: { error: error, id: id, data: data }
            }));
        }
    }

    /**
     * Conceptual method to trigger a delete operation.
     * Dispatches 'beforedelete' and 'afterdelete' events.
     */
    async deleteData(id) {
        const beforeDeleteEvent = new CustomEvent('beforedelete', {
            bubbles: true,
            composed: true,
            cancelable: true,
            detail: { id: id }
        });
        this.dispatchEvent(beforeDeleteEvent);

        if (beforeDeleteEvent.defaultPrevented) {
            console.log('Delete operation prevented.');
            return;
        }

        try {
            // Simulate API call
            const response = await fetch(`/api/delete/${id}`, {
                method: 'DELETE'
            });
            const responseData = await response.json();

            this.dispatchEvent(new CustomEvent('afterdelete', {
                bubbles: true,
                composed: true,
                detail: { response: responseData, id: id }
            }));
            return responseData;
        } catch (error) {
            console.error('Error deleting data:', error);
            this.dispatchEvent(new CustomEvent('errordelete', {
                bubbles: true,
                composed: true,
                detail: { error: error, id: id }
            }));
        }
    }

    // Event listener management for cleanup
    _addEventListeners() {
        // No component-level listeners needed for this version, as form listeners are managed separately.
    }

    _removeEventListeners() {
        // No component-level listeners to remove for this version.
    }
}

customElements.define('page-loader', PageLoader, { extends: 'article' });
    </script>
</body>
</html>
