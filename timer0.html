<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multi-Instance Timer Web Component (Light DOM)</title>
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f0f2f5;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
        }

        .main-container {
            text-align: center;
            max-width: 900px;
            width: 100%;
            margin-bottom: 40px;
            padding: 20px;
            background-color: white;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        /* Styles for the main timer-component web component */
        timer-component {
            display: block;
            width: 100%;
            max-width: 900px;
            margin-top: 20px;
            padding: 20px;
            background-color: white;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            text-align: center;
        }

        /* Styles for individual-timer instances */
        .individual-timer-instance { /* New class for light DOM */
            display: block;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            background-color: #fcfcfc;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
            text-align: center;
        }

        .timer-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        /* Styles for IndividualTimer's internal elements */
        .individual-timer-instance .timer-header {
            font-size: 1.5rem;
            font-weight: bold;
            color: #007bff;
            margin-bottom: 15px;
        }
        .individual-timer-instance .timer-display {
            font-size: 2.5rem;
            font-weight: bold;
            color: #343a40;
            margin-bottom: 20px;
            padding: 8px 15px;
            border: 2px solid #007bff;
            border-radius: 8px;
            display: inline-block;
            min-width: 180px;
        }
        .individual-timer-instance .timer-controls button {
            margin: 0 5px;
            padding: 8px 18px;
            font-size: 1rem;
            border-radius: 6px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            transition: transform 0.1s ease;
        }
        .individual-timer-instance .timer-controls button:hover {
            transform: translateY(-1px);
        }
        .individual-timer-instance .timer-controls button:active {
            transform: translateY(0);
            box-shadow: 0 0px 1px rgba(0,0,0,0.1);
        }
        .individual-timer-instance .comment-logs {
            background-color: #f8f9fa;
            border-radius: 8px;
            padding: 10px;
            max-height: 120px;
            overflow-y: auto;
            text-align: left;
            margin-top: 15px;
            font-size: 0.85rem;
            color: #495057;
            border: 1px solid #eee;
        }
        .individual-timer-instance .comment-log-item {
            margin-bottom: 5px;
            padding-bottom: 3px;
            border-bottom: 1px dashed #e9ecef;
        }
        .individual-timer-instance .comment-log-item:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }
        .individual-timer-instance .comment-log-time {
            font-weight: bold;
            color: #007bff;
            margin-right: 5px;
        }

        /* --- Offcanvas Dialog Styles (Global, but managed by TimerComponent) --- */
        dialog {
            border: none;
            padding: 0;
            margin: 0;
            background: transparent;
            max-width: none;
            max-height: none;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: flex-end; /* Always from bottom for comments */
            justify-content: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease-out;
            z-index: 1050;
            position: fixed; /* Crucial for light DOM dialog overlay */
            top: 0;
            left: 0;
        }

        dialog[open] {
            opacity: 1;
            pointer-events: auto;
        }

        dialog::backdrop {
            background-color: transparent; /* We use a custom backdrop overlay */
        }

        .comment-backdrop-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            opacity: 0;
            transition: opacity 0.3s ease-out;
            z-index: 1050;
        }

        .comment-panel-content {
            background-color: white;
            box-shadow: 0 -0.5rem 1rem rgba(0, 0, 0, 0.15);
            border-radius: 0.375rem 0.375rem 0 0;
            transition: transform 0.3s ease-out;
            position: relative;
            display: flex;
            flex-direction: column;
            z-index: 1051;
            width: 100%;
            max-width: 500px;
            height: auto;
            min-height: 150px;
            transform: translateY(100%);
        }

        dialog.is-open .comment-panel-content {
            transform: translateY(0);
        }
        dialog.is-open .comment-backdrop-overlay {
            opacity: 1;
        }

        .comment-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem;
            border-bottom: 1px solid #dee2e6;
        }
        .comment-title {
            margin-bottom: 0;
            line-height: 1.5;
            font-size: 1.25rem;
            color: #343a40;
        }
        .comment-body {
            padding: 1rem;
            flex-grow: 1;
            overflow-y: auto;
        }
        .btn-close {
            padding: 0.5rem;
            margin: -0.5rem -0.5rem -0.5rem auto;
            background-color: transparent;
            border: 0;
            opacity: 0.5;
            font-size: 1.25rem;
            line-height: 1;
            color: #000;
            text-shadow: none;
            cursor: pointer;
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16' fill='%23000'%3e%3cpath d='M.293.293a1 1 0 011.414 0L8 6.586 14.293.293a1 1 0 111.414 1.414L9.414 8l6.293 6.293a1 1 0 01-1.414 1.414L8 9.414l-6.293 6.293a1 1 0 01-1.414-1.414L6.586 8 .293 1.707A1 1 0 01.293.293z'/%3e%3c/svg%3e");
            background-repeat: no-repeat;
            background-position: center;
            background-size: 1em;
        }
        .btn-close:hover {
            opacity: 0.75;
        }

        .message-box {
            padding: 10px 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            font-size: 14px;
            display: block;
            word-wrap: break-word;
            text-align: center;
        }
        .message-box.alert-danger { background-color: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }
        .message-box.alert-success { background-color: #d4edda; color: #155724; border: 1px solid #c3e6cb; }

        /* Styles for the new mode toggle */
        .mode-toggle-section {
            margin-bottom: 25px;
            padding-bottom: 20px;
            border-bottom: 1px solid #eee;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
        }
        .mode-toggle-section .form-check-input {
            margin-top: 0; /* Align checkbox vertically with text */
        }
    </style>
</head>
<body>

    <div class="main-container">
        <h1 class="text-center mb-4 text-dark">Multi-Instance Timer Web Component Demo</h1>
        <p class="text-secondary fs-5">
            This component allows you to manage multiple independent timers.
            Each timer can be started, stopped, cleared, and have comments logged to it via an offcanvas modal.
            The timer continues to run until a comment is logged when stopped.
        </p>
    </div>

    <!-- The main custom web component for multiple timers -->
    <timer-component></timer-component>

    <!-- The dialog for comments, now in the light DOM -->
    <dialog id="globalCommentDialog">
        <div class="comment-backdrop-overlay" id="globalCommentBackdrop"></div>
        <div class="comment-panel-content" id="globalCommentPanel">
            <div class="comment-header">
                <h5 class="comment-title" id="globalCommentDialogTitle">Log Comment</h5>
                <button type="button" class="btn-close" aria-label="Close"></button>
            </div>
            <div class="comment-body">
                <div class="message-box d-none" id="globalDialogMessageBox"></div>
                <div class="input-group mb-3">
                    <input type="text" id="globalDialogCommentInput" class="form-control" placeholder="Enter your comment...">
                </div>
                <button id="globalDialogLogCommentBtn" class="btn btn-info w-100">Log Comment & Stop Timer</button>
            </div>
        </div>
    </dialog>


    <!-- Bootstrap JS (Popper.js and Bootstrap bundle) -->
    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.8/dist/umd/popper.min.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.min.js" crossorigin="anonymous"></script>

    <script>
        // --- Individual Timer Web Component (Light DOM) ---
        class IndividualTimer extends HTMLElement {
            constructor() {
                super();
                // No Shadow DOM

                // Initialize properties, but get attribute values in connectedCallback
                this.timerId = null;
                this.timerName = "Unnamed Timer";

                // Direct light DOM structure
                const rootDiv = document.createElement('div');
                rootDiv.classList.add('individual-timer-instance'); // Apply the main class here
                rootDiv.innerHTML = `
                    <div class="timer-header" data-id="timerNameDisplay"></div> <!-- Empty initially -->
                    <div class="timer-display" data-id="timerDisplay">00:00:00</div>
                    <div class="timer-controls">
                        <button data-id="startBtn" class="btn btn-success btn-sm">Start</button>
                        <button data-id="stopBtn" class="btn btn-danger btn-sm" disabled>Stop</button>
                        <button data-id="clearBtn" class="btn btn-warning btn-sm">Clear</button>
                    </div>
                    <div class="comment-logs" data-id="commentLogs">
                        <p class="text-muted mb-0">No comments for this timer.</p>
                    </div>
                `;
                this.appendChild(rootDiv); // Append this structure to the custom element


                // Get element references directly from `this` (the host element)
                this.timerDisplay = rootDiv.querySelector('[data-id="timerDisplay"]');
                this.timerNameDisplay = rootDiv.querySelector('[data-id="timerNameDisplay"]');
                this.startBtn = rootDiv.querySelector('[data-id="startBtn"]');
                this.stopBtn = rootDiv.querySelector('[data-id="stopBtn"]');
                this.clearBtn = rootDiv.querySelector('[data-id="clearBtn"]');
                this.commentLogs = rootDiv.querySelector('[data-id="commentLogs"]');

                this.isRunning = false;
                this.startTime = 0;
                this.elapsedTimeAtPause = 0;
                this.timerInterval = null;

                this.startBtn.addEventListener('click', this.requestStartTimer.bind(this)); // Changed to request start
                this.stopBtn.addEventListener('click', this.initiateStopTimer.bind(this));
                this.clearBtn.addEventListener('click', this.clearTimer.bind(this));

                this.updateDisplay(0);
                this.updateControlButtons();
            }

            connectedCallback() {
                // Get attribute values now that the element is connected to the DOM
                this.timerId = this.getAttribute('timer-id');
                this.timerName = this.getAttribute('timer-name') || `Timer ${this.timerId}`;
                this.timerNameDisplay.textContent = this.timerName; // Update the display here

                // Ensure initial state is correctly set after component is attached to DOM
                this.updateDisplay(this.elapsedTimeAtPause);
                this.updateControlButtons();
            }

            disconnectedCallback() {
                this._forceStopTimer(); // Clean up interval if removed from DOM
            }

            formatTime(milliseconds) {
                const totalSeconds = Math.floor(milliseconds / 1000);
                const hours = Math.floor(totalSeconds / 3600);
                const minutes = Math.floor((totalSeconds % 3600) / 60);
                const seconds = totalSeconds % 60;
                const pad = (num) => num.toString().padStart(2, '0');
                return `${pad(hours)}:${pad(minutes)}:${pad(seconds)}`;
            }

            updateDisplay(currentElapsedTime) {
                this.timerDisplay.textContent = this.formatTime(currentElapsedTime);
            }

            /**
             * Dispatches a request to the parent to start this timer.
             * The actual start logic is now handled by the parent component.
             */
            requestStartTimer() {
                if (this.isRunning) return; // Already running, no need to request

                this.dispatchEvent(new CustomEvent('timer-start-request', {
                    bubbles: true,
                    composed: false,
                    detail: {
                        timerId: this.timerId,
                        timerName: this.timerName
                    }
                }));
            }

            /**
             * Public method to actually start the timer. Called by the parent component.
             */
            start() {
                if (this.isRunning) return; // Defensive check, should not happen if orchestrated correctly

                this.isRunning = true;
                this.startTime = Date.now() - this.elapsedTimeAtPause;
                this.timerInterval = setInterval(() => {
                    const currentElapsedTime = Date.now() - this.startTime;
                    this.updateDisplay(currentElapsedTime);
                }, 1000);
                this.updateControlButtons();
            }


            initiateStopTimer() {
                if (!this.isRunning) return;

                // Emit a custom event to the parent component to show the comment offcanvas
                this.dispatchEvent(new CustomEvent('timer-stop-pending', {
                    bubbles: true, // Allow event to bubble up the DOM tree
                    composed: false, // Not crossing Shadow DOM boundary anymore
                    detail: {
                        timerId: this.timerId,
                        timerName: this.timerName,
                        currentTime: this.isRunning ? (Date.now() - this.startTime) : this.elapsedTimeAtPause
                    }
                }));

                // Temporarily disable stop button and enable clear, but timer keeps running visually
                this.startBtn.disabled = true; // Cannot start again until comment is logged
                this.stopBtn.disabled = true;
                this.clearBtn.disabled = true; // Cannot clear until decision is made
            }

            /**
             * Forces the timer to stop (used by parent after comment is logged or dialog dismissed).
             */
            _forceStopTimer() {
                if (!this.isRunning && !this.timerInterval) return;

                this.isRunning = false;
                clearInterval(this.timerInterval);
                this.timerInterval = null;
                this.elapsedTimeAtPause = Date.now() - this.startTime;
                this.updateControlButtons();
            }

            /**
             * Logs a comment to this specific timer's history. Called by the parent.
             * @param {string} commentText - The comment to log.
             * @param {string} formattedTime - The time associated with the comment.
             */
            logComment(commentText, formattedTime) {
                const noCommentsMessage = this.commentLogs.querySelector('p.text-muted');
                if (noCommentsMessage) {
                    noCommentsMessage.remove();
                }
                const logItem = document.createElement('div');
                logItem.classList.add('comment-log-item');
                logItem.innerHTML = `<span class="comment-log-time">[${formattedTime}]</span> ${commentText}`;
                this.commentLogs.prepend(logItem);
            }

            clearTimer() {
                this._forceStopTimer();
                this.elapsedTimeAtPause = 0;
                this.startTime = 0;
                this.updateDisplay(0);
                this.updateControlButtons();
                this.commentLogs.innerHTML = '<p class="text-muted mb-0">No comments for this timer.</p>';
            }

            updateControlButtons() {
                this.startBtn.disabled = this.isRunning;
                this.stopBtn.disabled = !this.isRunning;
                // Clear button disabled if timer is running (user must stop first) OR if elapsed time is 0
                this.clearBtn.disabled = this.isRunning || this.elapsedTimeAtPause === 0;
            }
        }

        if (!customElements.get('individual-timer')) {
            customElements.define('individual-timer', IndividualTimer);
        }

        // --- Main Timer Manager Web Component (Light DOM) ---
        class TimerComponent extends HTMLElement {
            constructor() {
                super();
                // No Shadow DOM

                // Direct light DOM structure for the manager itself
                const rootDiv = document.createElement('div');
                rootDiv.classList.add('timer-manager-container'); // Apply the main class here
                rootDiv.innerHTML = `
                    <div class="mode-toggle-section">
                        <div class="form-check form-switch">
                            <input class="form-check-input" type="checkbox" role="switch" id="singleTimerModeToggle" checked data-id="singleTimerModeCheckbox">
                            <label class="form-check-label" for="singleTimerModeToggle">Single Timer Mode</label>
                        </div>
                    </div>
                    <div class="add-timer-section">
                        <h4 class="text-secondary mb-3">Manage Timers</h4>
                        <button data-id="addTimerBtn" class="btn btn-primary">Add New Timer</button>
                    </div>

                    <div class="timer-grid" data-id="timersContainer">
                        <!-- Individual timer components will be added here -->
                    </div>
                `;
                this.appendChild(rootDiv);


                // Main component references (get from light DOM)
                this.addTimerBtn = rootDiv.querySelector('[data-id="addTimerBtn"]');
                this.timersContainer = rootDiv.querySelector('[data-id="timersContainer"]');
                this.singleTimerModeCheckbox = rootDiv.querySelector('[data-id="singleTimerModeCheckbox"]');
                this.timerCount = 0;

                // Offcanvas dialog references (now global, get from document)
                this.commentDialog = document.getElementById('globalCommentDialog');
                this.commentBackdrop = document.getElementById('globalCommentBackdrop');
                this.commentPanel = document.getElementById('globalCommentPanel');
                this.dialogCloseBtn = this.commentDialog.querySelector('.btn-close');
                this.dialogCommentInput = document.getElementById('globalDialogCommentInput');
                this.dialogLogCommentBtn = document.getElementById('globalDialogLogCommentBtn');
                this.dialogMessageBox = document.getElementById('globalDialogMessageBox');
                this.commentDialogTitle = document.getElementById('globalCommentDialogTitle');

                this.currentTimerStopping = null; // The timer that initiated a stop request
                this.singleTimerMode = this.singleTimerModeCheckbox.checked; // Global mode state
                this.activeTimerInstances = new Map(); // Map to store all IndividualTimer instances by ID

                // Attach event listeners
                this.addTimerBtn.addEventListener('click', this.addTimer.bind(this));
                this.dialogLogCommentBtn.addEventListener('click', this.logCommentAndFinalizeStop.bind(this));
                this.singleTimerModeCheckbox.addEventListener('change', () => {
                    this.singleTimerMode = this.singleTimerModeCheckbox.checked;
                    this.updateAllTimerControlButtons(); // Update all buttons based on new mode
                    if (this.singleTimerMode) {
                        // If switching to single mode, ensure only one is running
                        this.ensureOnlyOneTimerRunning();
                    }
                });


                // Dialog close events
                this.dialogCloseBtn.addEventListener('click', () => this.hideCommentOffcanvas(false));
                this.commentBackdrop.addEventListener('click', () => this.hideCommentOffcanvas(false));
                this.commentDialog.addEventListener('close', () => {
                    if (this.currentTimerStopping) {
                        this.currentTimerStopping.updateControlButtons();
                        this.currentTimerStopping = null;
                        this.dialogCommentInput.value = '';
                        this.hideDialogMessage();
                    }
                    this.commentDialog.classList.remove('is-open');
                });

                // Listen for custom events from individual timers (bubbles up through light DOM)
                this.timersContainer.addEventListener('timer-start-request', this.handleTimerStartRequest.bind(this));
                this.timersContainer.addEventListener('timer-stop-pending', this.handleTimerStopPending.bind(this));


                // Add an initial timer
                this.addTimer();
            }

            /**
             * Adds a new individual-timer component to the container.
             */
            addTimer() {
                this.timerCount++;
                const timerId = `timer-${this.timerCount}`;
                const individualTimer = document.createElement('individual-timer');
                individualTimer.setAttribute('timer-id', timerId);
                individualTimer.setAttribute('timer-name', `My Timer ${this.timerCount}`);
                this.timersContainer.appendChild(individualTimer);
                this.activeTimerInstances.set(timerId, individualTimer); // Store instance
            }

            /**
             * Handles the 'timer-start-request' event from an individual-timer.
             * Orchestrates starting a timer based on single/multiple mode.
             * @param {CustomEvent} event - The custom event from the individual-timer.
             */
            handleTimerStartRequest(event) {
                const { timerId, timerName } = event.detail;
                const requestingTimer = this.activeTimerInstances.get(timerId);

                if (!requestingTimer) {
                    console.error(`Attempted to start timer ${timerId}, but instance not found.`);
                    return;
                }

                if (this.singleTimerMode) {
                    // Stop any other currently running timers
                    let stoppedOtherTimer = false;
                    this.activeTimerInstances.forEach((timer) => {
                        if (timer.isRunning && timer.timerId !== requestingTimer.timerId) {
                            timer._forceStopTimer(); // Force stop the other timer
                            console.log(`Stopped timer "${timer.timerName}" to enforce Single Timer Mode.`);
                            stoppedOtherTimer = true;
                        }
                    });
                    if (stoppedOtherTimer) {
                         this.showDialogMessage(`Stopped other timers to start "${timerName}".`, 'info', true);
                    }
                }
                // Now, start the requesting timer
                requestingTimer.start();
                this.updateAllTimerControlButtons(); // Update all buttons after a start
            }

            /**
             * Handles the 'timer-stop-pending' event from an individual-timer.
             * Shows the offcanvas dialog.
             * @param {CustomEvent} event - The custom event from the individual-timer.
             */
            handleTimerStopPending(event) {
                const { timerId, timerName, currentTime } = event.detail;
                this.currentTimerStopping = this.activeTimerInstances.get(timerId);

                if (this.currentTimerStopping) {
                    this.commentDialogTitle.textContent = `Log Comment for ${timerName} (${this.currentTimerStopping.formatTime(currentTime)})`;
                    this.showCommentOffcanvas();
                } else {
                    console.error(`Error: Could not find individual-timer with ID ${timerId}`);
                }
            }

            /**
             * Handles logging a comment and then stopping the associated timer.
             */
            logCommentAndFinalizeStop() {
                const commentText = this.dialogCommentInput.value.trim();
                if (!commentText) {
                    this.showDialogMessage('Please enter a comment.', 'danger');
                    return;
                }

                if (this.currentTimerStopping) {
                    const formattedTime = this.currentTimerStopping.formatTime(this.currentTimerStopping.isRunning ? (Date.now() - this.currentTimerStopping.startTime) : this.currentTimerStopping.elapsedTimeAtPause);
                    this.currentTimerStopping.logComment(commentText, formattedTime);
                    this.currentTimerStopping._forceStopTimer(); // Tell the individual timer to finally stop
                    this.showDialogMessage('Comment logged and timer stopped!', 'success');
                } else {
                    this.showDialogMessage('Error: No timer context found to stop.', 'danger');
                }

                this.currentTimerStopping = null;
                this.dialogCommentInput.value = '';
                this.hideCommentOffcanvas(true);
                this.updateAllTimerControlButtons(); // Update all buttons after a stop
            }

            /**
             * Iterates through all managed timers and updates their button states.
             * This is called after a global mode change or a timer start/stop event.
             */
            updateAllTimerControlButtons() {
                this.activeTimerInstances.forEach(timer => {
                    timer.updateControlButtons();
                });
            }

            /**
             * Ensures only one timer is running when switching to single timer mode.
             * Stops all but the first found running timer (if any).
             */
            ensureOnlyOneTimerRunning() {
                let firstRunningTimerFound = false;
                this.activeTimerInstances.forEach(timer => {
                    if (timer.isRunning) {
                        if (!firstRunningTimerFound) {
                            firstRunningTimerFound = true;
                        } else {
                            timer._forceStopTimer(); // Stop subsequent running timers
                            console.log(`Stopped timer "${timer.timerName}" during single timer mode enforcement.`);
                            this.showDialogMessage(`Stopped timer "${timer.timerName}" to enforce Single Timer Mode.`, 'info', true);
                        }
                    }
                });
                this.updateAllTimerControlButtons();
            }


            /**
             * Shows the comment offcanvas dialog.
             */
            showCommentOffcanvas() {
                this.commentDialog.showModal();
                requestAnimationFrame(() => {
                    this.commentDialog.classList.add('is-open');
                    this.dialogCommentInput.focus();
                });
            }

            /**
             * Hides the comment offcanvas dialog.
             * @param {boolean} performedStop - True if the timer was actually stopped (comment logged).
             */
            hideCommentOffcanvas(performedStop) {
                this.commentDialog.classList.remove('is-open');

                const handleTransitionEnd = () => {
                    this.commentPanel.removeEventListener('transitionend', handleTransitionEnd);
                    this.commentDialog.close();
                    this.dialogCommentInput.value = '';
                    this.hideDialogMessage();

                    if (!performedStop && this.currentTimerStopping) {
                        this.currentTimerStopping.updateControlButtons();
                    }
                    this.currentTimerStopping = null;
                };

                this.commentPanel.addEventListener('transitionend', handleTransitionEnd, { once: true });

                setTimeout(() => {
                    if (this.commentDialog.open) {
                        this.commentDialog.close();
                        this.dialogCommentInput.value = '';
                        this.hideDialogMessage();
                        if (!performedStop && this.currentTimerStopping) {
                            this.currentTimerStopping.updateControlButtons();
                        }
                        this.currentTimerStopping = null;
                    }
                }, 400);
            }

            /**
             * Displays a message within the dialog's message box.
             * @param {string} message - The message to display.
             * @param {string} type - 'success' or 'danger' for styling.
             * @param {boolean} autoHide - Whether the message should hide automatically after 3 seconds.
             */
            showDialogMessage(message, type = 'info', autoHide = true) {
                this.dialogMessageBox.textContent = message;
                this.dialogMessageBox.classList.remove('d-none', 'alert-success', 'alert-danger');
                this.dialogMessageBox.classList.add(`alert-${type}`);
                if (autoHide) {
                    setTimeout(() => {
                        this.hideDialogMessage();
                    }, 3000);
                }
            }

            /**
             * Hides the dialog's message box.
             */
            hideDialogMessage() {
                this.dialogMessageBox.classList.add('d-none');
            }
        }

        if (!customElements.get('timer-component')) {
            customElements.define('timer-component', TimerComponent);
        }
    </script>

</body>
</html>
